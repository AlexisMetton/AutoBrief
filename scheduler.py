#!/usr/bin/env python3
"""
Script de planification pour GitHub Actions
V√©rifie et g√©n√®re automatiquement les r√©sum√©s selon la planification des utilisateurs
"""

import os
import sys
import json
import logging
from datetime import datetime, timedelta
from pathlib import Path
from email.mime.text import MIMEText

# Configuration du logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('scheduler_results.log'),
        logging.StreamHandler()
    ]
)

# Ajouter le r√©pertoire parent au path pour importer nos modules
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from config import Config
from newsletter_manager import NewsletterManager

class AutoBriefScheduler:
    def __init__(self):
        self.config = Config()
        self.data_dir = "user_data"
        self.logger = logging.getLogger(__name__)
        
    def get_all_users(self):
        """R√©cup√®re tous les utilisateurs depuis GitHub Gist"""
        users = []
        
        try:
            # Charger les donn√©es depuis GitHub Gist
            gist_id = os.getenv('GIST_ID')
            
            if not gist_id:
                self.logger.info("Aucun GIST_ID trouv√© dans les secrets GitHub")
                return users
            
            import requests
            response = requests.get(f'https://api.github.com/gists/{gist_id}')
            
            if response.status_code == 200:
                gist_data = response.json()
                if 'user_data.json' in gist_data['files']:
                    content = gist_data['files']['user_data.json']['content']
                    all_users_data = json.loads(content)
                    
                    for user_email, user_data in all_users_data.items():
                        settings = user_data.get('settings', {})
                        
                        # V√©rifier si l'utilisateur a activ√© l'envoi automatique
                        if settings.get('auto_send', False):
                            users.append({
                                'email': user_email,
                                'settings': settings,
                                'newsletters': user_data.get('newsletters', [])
                            })
            else:
                self.logger.error(f"Erreur lors de la r√©cup√©ration du Gist: {response.status_code}")
                    
        except Exception as e:
            self.logger.error(f"Erreur lors du chargement des donn√©es utilisateur: {e}")
        
        return users
    
    def should_run_for_user(self, user_settings):
        """V√©rifie si un r√©sum√© doit √™tre g√©n√©r√© pour cet utilisateur"""
        if not user_settings.get('auto_send', False):
            self.logger.info("‚ùå Auto-send d√©sactiv√©")
            return False
        
        # V√©rifier d'abord le jour et l'heure
        if not self.is_scheduled_time(user_settings):
            self.logger.info("‚è∞ Pas encore l'heure pour cet utilisateur")
            return False
        
        last_run = user_settings.get('last_run')
        if not last_run:
            self.logger.info("‚úÖ Premi√®re ex√©cution")
            return True
        
        try:
            last_run_date = datetime.fromisoformat(last_run)
            frequency = user_settings.get('frequency', 'weekly')
            
            # Pour les planifications par jour/heure, on ne v√©rifie pas la fr√©quence temporelle
            # On s'ex√©cute si c'est le bon jour et la bonne heure
            if frequency in ['daily', 'weekly', 'monthly']:
                # Pour les planifications par jour/heure, on s'ex√©cute toujours si c'est le bon moment
                # On ne bloque pas les ex√©cutions multiples le m√™me jour
                self.logger.info(f"‚úÖ Planification par jour/heure - Ex√©cution autoris√©e")
                return True
            else:
                # Pour les autres fr√©quences, utiliser l'ancienne logique
                if frequency == 'daily':
                    should_run = datetime.now() - last_run_date >= timedelta(days=1)
                elif frequency == 'weekly':
                    should_run = datetime.now() - last_run_date >= timedelta(weeks=1)
                elif frequency == 'monthly':
                    should_run = datetime.now() - last_run_date >= timedelta(days=30)
                else:
                    should_run = True
                
                if should_run:
                    self.logger.info(f"‚úÖ Temps d'ex√©cution - Fr√©quence: {frequency}")
                else:
                    self.logger.info(f"‚è≥ Pas encore le temps - Fr√©quence: {frequency}")
                
                return should_run
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur v√©rification fr√©quence: {e}")
            return True
        
        return False
    
    def is_scheduled_time(self, user_settings):
        """V√©rifie si c'est le bon jour et la bonne heure pour l'ex√©cution"""
        try:
            schedule_day = user_settings.get('schedule_day', 'monday')
            schedule_time = user_settings.get('schedule_time', '09:00')
            
            now = datetime.now()
            current_day = now.strftime('%A').lower()
            current_time = now.strftime('%H:%M')
            
            # V√©rifier le jour (pour les fr√©quences weekly/monthly)
            if user_settings.get('frequency', 'weekly') in ['weekly', 'monthly']:
                if current_day != schedule_day.lower():
                    self.logger.info(f"üìÖ Jour incorrect - Actuel: {current_day}, Attendu: {schedule_day.lower()}")
                    return False
                else:
                    self.logger.info(f"üìÖ Jour correct - {current_day}")
            
            # V√©rifier l'heure (avec une marge de 30 minutes pour GitHub Actions)
            target_hour = int(schedule_time.split(':')[0])
            target_minute = int(schedule_time.split(':')[1])
            current_hour = now.hour
            current_minute = now.minute
            
            # GitHub Actions s'ex√©cute √† l'heure pile, on accepte +/- 30 minutes
            time_diff = abs((current_hour * 60 + current_minute) - (target_hour * 60 + target_minute))
            self.logger.info(f"‚è∞ Heure - Actuelle: {current_hour}:{current_minute:02d}, Cible: {target_hour}:{target_minute:02d}, Diff: {time_diff}min")
            return time_diff <= 30
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur v√©rification horaire: {e}")
            return True  # En cas d'erreur, on autorise l'ex√©cution
    
    def send_email(self, to_email, subject, content):
        """Envoie un email via le script d'envoi"""
        try:
            import subprocess
            
            # D√©finir les variables d'environnement pour le script
            # Sauvegarder le contenu dans un fichier temporaire
            temp_content_file = 'temp_email_content.html'
            with open(temp_content_file, 'w', encoding='utf-8') as f:
                f.write(content)
            
            # Pr√©parer les variables d'environnement pour le script
            env = os.environ.copy()
            env['TO_EMAIL'] = to_email
            env['SUBJECT'] = subject
            env['CONTENT_FILE'] = temp_content_file
            
            self.logger.info(f"üìß Envoi email pour {to_email}")
            self.logger.info(f"üìß Sujet: {subject}")
            
            # Ex√©cuter le script d'envoi d'email final
            result = subprocess.run(
                ['python', 'send_email_final.py'],
                env=env,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            # Afficher les logs
            if result.stdout:
                for line in result.stdout.strip().split('\n'):
                    self.logger.info(f"üìß {line}")
            
            if result.stderr:
                for line in result.stderr.strip().split('\n'):
                    self.logger.error(f"‚ùå {line}")
            
            if result.returncode == 0:
                self.logger.info(f"‚úÖ Email envoy√© avec succ√®s √† {to_email}")
                return True
            else:
                self.logger.error(f"‚ùå √âchec envoi email (code: {result.returncode})")
                return False
            
        except subprocess.TimeoutExpired:
            self.logger.error("‚ùå Timeout lors de l'envoi d'email")
            return False
        except Exception as e:
            self.logger.error(f"‚ùå Erreur envoi email: {e}")
            return False
    
    def process_user_newsletters(self, user_info):
        """Traite les newsletters pour un utilisateur et g√©n√®re le r√©sum√©"""
        try:
            self.logger.info(f"üîÑ Traitement pour {user_info['email']}")
            
            newsletters = user_info['newsletters']
            if not newsletters:
                self.logger.warning(f"‚ö†Ô∏è Aucune newsletter pour {user_info['email']}")
                return False
            
            # En mode GitHub Actions, on simule le traitement
            # Dans un vrai d√©ploiement, on ferait appel √† l'API de l'application Streamlit
            self.logger.info(f"‚úÖ {len(newsletters)} newsletters √† traiter pour {user_info['email']}")
            self.logger.info(f"üìß Newsletters: {', '.join(newsletters)}")
            
            # Mettre √† jour la date de derni√®re ex√©cution
            self.update_last_run(user_info['email'])
            
            # G√©n√©rer le vrai r√©sum√© avec l'IA
            try:
                # Simuler une session utilisateur pour NewsletterManager
                import streamlit as st
                st.session_state['user_email'] = user_info['email']
                st.session_state['authenticated'] = True
                
                self.logger.info(f"üîß Configuration session: user_email={user_info['email']}")
                
                from newsletter_manager import NewsletterManager
                newsletter_manager = NewsletterManager()
                
                # Forcer l'email utilisateur dans le NewsletterManager
                newsletter_manager.user_email = user_info['email']
                
                # Passer directement les donn√©es utilisateur
                newsletter_manager.newsletters = user_info.get('newsletters', [])
                newsletter_manager.user_settings = user_info.get('settings', {})
                
                self.logger.info(f"üîß Donn√©es utilisateur pass√©es au NewsletterManager")
                
                # Configurer l'acc√®s Gmail pour le NewsletterManager
                try:
                    from secure_auth import SecureAuth
                    auth = SecureAuth()
                    
                    # Passer les credentials Google depuis GitHub Actions
                    google_credentials = os.getenv('GOOGLE_CREDENTIALS')
                    if google_credentials:
                        auth.set_external_credentials(google_credentials)
                        self.logger.info(f"üîß Credentials Google configur√©s pour SecureAuth")
                    else:
                        self.logger.error(f"‚ùå GOOGLE_CREDENTIALS non trouv√© dans les variables d'environnement")
                    
                    # Configurer l'auth pour le NewsletterManager
                    newsletter_manager.auth = auth
                    
                    self.logger.info(f"üîß Gmail auth configur√© pour NewsletterManager")
                except Exception as e:
                    self.logger.error(f"‚ùå Erreur configuration Gmail auth: {e}")
                
                self.logger.info(f"üîß NewsletterManager user_email: {newsletter_manager.user_email}")
                self.logger.info(f"üîß Newsletters configur√©es: {len(newsletter_manager.newsletters)}")
                
                # G√©n√©rer le r√©sum√© r√©el avec l'IA
                self.logger.info(f"üîß Tentative de g√©n√©ration du r√©sum√© IA...")
                summary = newsletter_manager.process_newsletters(send_email=False)
                self.logger.info(f"üîß R√©sultat process_newsletters: {summary is not None}")
                if summary:
                    self.logger.info(f"üîß Type du r√©sum√©: {type(summary)}")
                    self.logger.info(f"üîß Longueur: {len(str(summary))}")
                
                if summary:
                    self.logger.info(f"üìÑ R√©sum√© IA g√©n√©r√© pour {user_info['email']} le {datetime.now().strftime('%d/%m/%Y %H:%M')}")
                    self.logger.info(f"üìÑ Longueur du r√©sum√©: {len(summary)} caract√®res")
                else:
                    self.logger.error(f"‚ùå √âchec g√©n√©ration r√©sum√© IA pour {user_info['email']}")
                    self.logger.error(f"‚ùå V√©rifiez les credentials Google et les permissions Gmail")
                    return False
                    
            except Exception as e:
                self.logger.error(f"‚ùå Erreur g√©n√©ration r√©sum√© IA: {e}")
                summary = f"<p>Erreur lors de la g√©n√©ration du r√©sum√©: {str(e)}</p>"
            
            # Envoyer l'email de r√©sum√©
            notification_email = user_info['settings'].get('notification_email')
            if notification_email and notification_email.strip():
                subject = f"üìß R√©sum√© AutoBrief - {datetime.now().strftime('%d/%m/%Y')}"
                content = f"""
                <h2>üìß R√©sum√© de vos newsletters</h2>
                <p>Bonjour,</p>
                <p>Voici votre r√©sum√© automatique g√©n√©r√© le {datetime.now().strftime('%d/%m/%Y √† %H:%M')} :</p>
                <div style="background-color: #f5f5f5; padding: 15px; border-radius: 5px;">
                    {summary}
                </div>
                <p>---</p>
                <p><em>G√©n√©r√© automatiquement par AutoBrief</em></p>
                """
                
                if self.send_email(notification_email, subject, content):
                    self.logger.info(f"‚úÖ Email de r√©sum√© envoy√© √† {notification_email}")
                else:
                    self.logger.error(f"‚ùå √âchec envoi email √† {notification_email}")
            else:
                self.logger.warning(f"‚ö†Ô∏è Aucune adresse email de notification configur√©e pour {user_info['email']}")
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur traitement {user_info['email']}: {e}")
            return False
    
    
    def update_last_run(self, user_email):
        """Met √† jour la date de derni√®re ex√©cution pour un utilisateur dans GitHub Gist"""
        try:
            gist_id = os.getenv('GIST_ID')
            
            if not gist_id:
                self.logger.error("GIST_ID non trouv√© dans les variables d'environnement")
                return
            
            import requests
            
            # Charger les donn√©es actuelles du Gist
            response = requests.get(f'https://api.github.com/gists/{gist_id}')
            
            if response.status_code == 200:
                gist_data = response.json()
                if 'user_data.json' in gist_data['files']:
                    content = gist_data['files']['user_data.json']['content']
                    all_users_data = json.loads(content)
                    
                    # Mettre √† jour la date pour cet utilisateur
                    if user_email in all_users_data:
                        all_users_data[user_email]['settings']['last_run'] = datetime.now().isoformat()
                        
                        # Mettre √† jour le Gist
                        update_data = {
                            "files": {
                                "user_data.json": {
                                    "content": json.dumps(all_users_data, indent=2, ensure_ascii=False)
                                }
                            }
                        }
                        
                        update_response = requests.patch(
                            f'https://api.github.com/gists/{gist_id}',
                            json=update_data,
                            headers={'Accept': 'application/vnd.github.v3+json'}
                        )
                        
                        if update_response.status_code == 200:
                            self.logger.info(f"‚úÖ Date de derni√®re ex√©cution mise √† jour pour {user_email}")
                        else:
                            self.logger.error(f"‚ùå Erreur lors de la mise √† jour du Gist: {update_response.status_code}")
                    else:
                        self.logger.warning(f"‚ö†Ô∏è Utilisateur {user_email} non trouv√© dans les donn√©es")
                else:
                    self.logger.error("Fichier user_data.json non trouv√© dans le Gist")
            else:
                self.logger.error(f"‚ùå Erreur lors de la r√©cup√©ration du Gist: {response.status_code}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur mise √† jour: {e}")
    
    def run_scheduler(self):
        """Fonction principale du scheduler"""
        self.logger.info(f"üöÄ D√©marrage du scheduler AutoBrief - {datetime.now()}")
        
        users = self.get_all_users()
        self.logger.info(f"üë• {len(users)} utilisateurs avec auto-send activ√©")
        
        processed = 0
        for user_info in users:
            if self.should_run_for_user(user_info['settings']):
                self.logger.info(f"‚è∞ Il est temps de traiter {user_info['email']}")
                
                if self.process_user_newsletters(user_info):
                    processed += 1
                    self.logger.info(f"‚úÖ Traitement r√©ussi pour {user_info['email']}")
                else:
                    self.logger.error(f"‚ùå √âchec traitement pour {user_info['email']}")
            else:
                self.logger.info(f"‚è≥ Pas encore l'heure pour {user_info['email']}")
        
        self.logger.info(f"üéØ Scheduler termin√© - {processed} utilisateurs trait√©s")
        return processed

def main():
    """Point d'entr√©e principal"""
    scheduler = AutoBriefScheduler()
    scheduler.run_scheduler()

if __name__ == "__main__":
    main()
